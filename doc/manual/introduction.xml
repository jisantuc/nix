<chapter>
  <title>Introduction</title>

  <sect1>
    <title>The problem space</title>

    <para>
      Nix is a system for controlling the automatic creation and distribution
      of data, such as computer programs and other software artifacts.  This is
      a very general problem, and there are many applications that fall under
      this description.
    </para>

    <sect2>
      <title>Build management</title>

      <para>
	Build management tools are used to perform <emphasis>software
	  builds</emphasis>, that is, the construction of derived products
	(<emphasis>derivates)</emphasis>) such as executable programs from
	source code.  A commonly used build tool is Make, which is a standard
	tool on Unix systems. These tools have to deal with several issues:
	<itemizedlist>

	  <listitem>
	    <para>
	      <emphasis>Efficiency</emphasis>.  Since building large systems
	      can take a substantial amount of time, it is desirable that build
	      steps that have been performed in the past are not repeated
	      unnecessarily, i.e., if a new build differs from a previous build
	      only with respect to certain sources, then only the build steps
	      that (directly or indirectly) <emphasis>depend</emphasis> on
	      those sources should be redone.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <emphasis>Correctness</emphasis> is this context means that the
	      derivates produced by a build are always consistent with the
	      sources, that is, they are equal to what we would get if we were
	      to build the derivates from those sources.  This requirement is
	      trivially met when we do a full, unconditional build, but is far
	      from trivial under the requirement of efficiency, since it is not
	      easy to determine which derivates are affected by a change to a
	      source.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <emphasis>Variability</emphasis> is the property that a software
	      system can be built in a (potentially large) number of variants.
	      Variation exists both in <emphasis>time</emphasis>---the
	      evolution of different versions of an artifact---and in
	      <emphasis>space</emphasis>---the artifact might have
	      configuration options that lead to variants that differ in the
	      features they support (for example, a system might be built with
	      or without debugging information).
	    </para>

	    <para>
	      Build managers historically have had good support for variation
	      in time (rebuilding the system in an intelligent way when sources
	      change is one of the primary reasons to use a build manager), but
	      not always for variation in space.  For example,
	      <command>make</command> will not automatically ensure that
	      variant builds are properly isolated from each other (they will
	      in fact overwrite each other unless special precautions are
	      taken).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <emphasis>High-level system modelling language</emphasis>.  The
	      language in which one describes what and how derivates are to be
	      produced should have sufficient abstraction facilities to make it
	      easy to specify the derivation of even very large systems.  Also,
	      the language should be <emphasis>modular</emphasis> to enable
	      components from possible different sources to be easily combined.
	    </para>
	  </listitem>

	</itemizedlist>
      </para>

    </sect2>

    <sect2>
      <title>Package management</title>

      <para>
	After software has been built, is must also be
	<emphasis>deployed</emphasis> in the intended target environment, e.g.,
	the user's workstation.  Examples include the Red Hat package manager
	(RPM), Microsoft's MSI, and so on.  Here also we have several issues to
	contend with:
	<itemizedlist>
	  <listitem>
	    <para>
	      The <emphasis>creation</emphasis> of packages from some formal
	      description of what artifacts should be distributed in the
	      package.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      The <emphasis>deployment</emphasis> of packages, that is, the
	      mechanism by which we get them onto the intended target
	      environment.  This can be as simple as copying a file, but
	      complexity comes from the wide range of possible installation
	      media (such as a network install), and the scalability of the
	      process (if a program must be installed on a thousand systems, we
	      do not want to visit each system and perform some manual steps to
	      install the program on that system; that is, the complexity for
	      the system administrator should be constant, not linear).
	    </para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect2>

  </sect1>


  <!--######################################################################-->

  <sect1>
    <title>What Nix provides</title>

    <para>
      Here is a summary of Nix's main features:
    </para>

    <itemizedlist>

      <listitem>
	<para>
	  <emphasis>Reliable dependencies.</emphasis>  Builds of file system
	  objects depend on other file system object, such as source files,
	  tools, and so on.  We would like to ensure that a build does not
	  refer to any objects that have not been declared as inputs for that
	  build.  This is important for several reasons.  First, if any of the
	  inputs change, we need to rebuild the things that depend on them to
	  maintain consistency between sources and derivates.  Second, when we
	  <emphasis>deploy</emphasis> file system objects (that is, copy them
	  to a different system), we want to be certain that we copy everything
	  that we need.
	</para>

	<para>
	  Nix ensures this by building and storing file system objects in paths
	  that are infeasible to predict in advance.  For example, the
	  artifacts of a package <literal>X</literal> might be stored in
	  <filename>/nix/store/d58a0606ed616820de291d594602665d-X</filename>,
	  rather than in, say, <filename>/usr/lib</filename>.  The path
	  component <filename>d58a...</filename> is actually a cryptographic
	  hash of all the inputs (i.e., sources, requisites, and build flags)
	  used in building <literal>X</literal>, and as such is very fragile:
	  any change to the inputs will change the hash.  Therefore it is not
	  sensible to <emphasis>hard-code</emphasis> such a path into the build
	  scripts of a package <literal>Y</literal> that uses
	  <literal>X</literal> (as does happen with <quote>fixed</quote> paths
	  such as <filename>/usr/lib</filename>).  Rather, the build script of
	  package <literal>Y</literal> is parameterised with the actual
	  location of <literal>X</literal>, which is supplied by the Nix
	  system.
	</para>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Support for variability.</emphasis>  
	</para>
	
	<para>
	  As stated above, the path name of a file system object contain a
	  cryptographic hash of all inputs involved in building it.  A change to
	  any of the inputs will cause the hash to change--and by extension,
	  the path name.  These inputs include both sources (variation in time)
	  and configuration options (variation in space).  Therefore variants
	  of the same package don't clash---they can co-exist peacefully within
	  the same file system.  So thanks to Nix's mechanism for reliably
	  dealing with dependencies, we obtain management of variants for free
	  (or, to quote Simon Peyton-Jone, it's not free, but it has already
	  been paid for).
	</para>

      </listitem>

      <listitem>
	<para>
	  <emphasis>Transparent source/binary deployment.</emphasis>
	</para>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Easy configuration duplication.</emphasis>
	</para>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Automatic storage management.</emphasis>
	</para>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Atomic upgrades and rollbacks.</emphasis>
	</para>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Support for many simultaneous configurations.</emphasis>
	</para>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Portability.</emphasis>  Nix is quite portable.  Contrary
	  to build systems like those in, e.g., Vesta and ClearCase [sic?], it
	  does not rely on operating system extensions.
	</para>
      </listitem>

    </itemizedlist>

    <para>
      Here is what Nix doesn't yet provide, but will:
    </para>

    <itemizedlist>

      <listitem>
	<para>
	  <emphasis>Build management.</emphasis>  In principle it is already
	  possible to do build management using Fix (by writing builders that
	  perform appropriate build steps), but the Fix language is not yet
	  powerful enough to make this pleasant.  The <ulink
	    url='http://www.cs.uu.nl/~eelco/maak/'>Maak build manager</ulink>
	  should be retargeted to produce Nix expressions, or alternatively,
	  extend Fix with Maak's semantics and concrete syntax (since Fix needs
	  a concrete syntax anyway).  Another interesting idea is to write a
	  <command>make</command> implementation that uses Nix as a back-end to
	  support <ulink
	    url='http://www.research.att.com/~bs/bs_faq.html#legacy'>legacy</ulink> 
	  build files.
	</para>
      </listitem>

    </itemizedlist>

  </sect1>


  <!--######################################################################-->

  <sect1>
    <title>The Nix system</title>

    <para>
      ...
    </para>

    <para>
      Existing tools in this field generally both a underlying model (such as
      the derivation graph of build tools, or the versioning scheme that
      determines when two packages are <quote>compatible</quote> in a package
      management system) and a formalism that allows ...
    </para>

    <para>
      Following the principle of separation of mechanism and policy, the Nix
      system separates the <emphasis>low-level aspect</emphasis> of file system
      object management form the <emphasis>high-level aspect</emphasis> of the
      ...
    </para>

  </sect1>

</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->
