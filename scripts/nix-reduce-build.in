#! @shell@

WORKING_DIRECTORY=$(mktemp -d "${TMPDIR:-/tmp}"/nix-reduce-build-XXXXXX);
cd "$WORKING_DIRECTORY";

if test -z "$1" || test "a--help" = "a$1" ; then
	echo 'nix-reduce-build (paths or Nix expressions) -- (package sources)' >&2
	echo As in: >&2
	echo nix-reduce-build /etc/nixos/nixos -- ssh://user@somewhere.nowhere.example.org >&2
	echo nix-reduce-build /etc/nixos/nixos -- \\
	echo "   " \''http://somewhere.nowhere.example.org/nix/nix-http-export.cgi?needed_path='\' >&2
	echo "  store path name will be added into the end of the URL" >&2
	echo nix-reduce-build /etc/nixos/nixos -- file://home/user/nar/ >&2
	echo "  that should be a directory where gzipped 'nix-store --export' ">&2
	echo "  files are located (they should have .nar.gz extension)"  >&2
	echo "        Or all together: " >&2
	echo -e nix-reduce-build /expr.nix /e2.nix -- \\\\\\\n\
	"    ssh://a@b.example.com http://n.example.com/get-nar?q= file://nar/" >&2
	exit;
fi;

while ! test "$1" = "--" || test "$1" = "" ; do 
	echo "$1" >> initial; >&2
	shift;
done
shift;
echo Will work on $(cat initial | wc -l) targets. >&2

while read ; do
	case "$REPLY" in 
		${NIX_STORE_PATH:-/nix/store}/*)
			echo "$REPLY" >> paths; >&2
			;;
		*)
			nix-instantiate "$REPLY" >> paths;
			;;
	esac;
done < initial;
echo Proceeding $(cat paths | wc -l) paths. >&2

while read; do
	case "$REPLY" in
		*.drv)
			echo "$REPLY" >> derivers; >&2
			;;
		*)
			nix-store --query --deriver "$REPLY" >>derivers;
			;;
	esac;
done < paths;
echo Found $(cat derivers | wc -l) derivers. >&2

cat derivers | xargs nix-store --query -R > derivers-closure;
echo Proceeding at most $(cat derivers-closure | wc -l) derivers. >&2

cat derivers-closure | egrep '[.]drv$' | xargs nix-store --query --outputs > wanted-paths;
cat derivers-closure | egrep -v '[.]drv$' >> wanted-paths;
echo Prepared $(cat wanted-paths | wc -l) paths to get. >&2

cat wanted-paths | xargs nix-store --check-validity --print-invalid > needed-paths;
echo We need $(cat needed-paths | wc -l) paths. >&2

if test -z "$1" ; then
	cat needed-paths;	
fi;

for i in "$@"; do 
	sshHost="${i#ssh://}";
	httpHost="${i#http://}";
	httpsHost="${i#https://}";
	filePath="${i#file:/}";
	if [ "$i" != "$sshHost" ]; then
		cat needed-paths | while read; do 
			echo "Getting $REPLY and its closure over ssh" >&2
			nix-copy-closure --from "$sshHost" --gzip "$REPLY" </dev/null || true; 
		done;
	elif [ "$i" != "$httpHost" ] || [ "$i" != "$httpsHost" ]; then
		cat needed-paths | while read; do
			echo "Getting $REPLY over http/https" >&2
			curl ${BAD_CERTIFICATE:+-k} -L "$i${REPLY##*/}" | gunzip | nix-store --import;
		done;
	elif [ "$i" != "filePath" ] ; then
		cat needed-paths | while read; do 
			echo "Installing $REPLY from file" >&2
			gunzip < "$filePath/${REPLY##*/}".nar.gz | nix-store --import;
		done;
	fi;
	mv needed-paths wanted-paths;
	cat wanted-paths | xargs nix-store --check-validity --print-invalid > needed-paths;
	echo We still need $(cat needed-paths | wc -l) paths. >&2
done;

cd /
rm -r "$WORKING_DIRECTORY"
