#! @perl@ -w -I@libexecdir@/nix

use strict;
use File::Temp qw(tempdir);
use readmanifest;

my $tmpDir = tempdir("nix-pull.XXXXXX", CLEANUP => 1, TMPDIR => 1)
    or die "cannot create a temporary directory";

my $binDir = $ENV{"NIX_BIN_DIR"};
$binDir = "@bindir@" unless defined $binDir;

my $libexecDir = $ENV{"NIX_LIBEXEC_DIR"};
$libexecDir = "@libexecdir@" unless defined $libexecDir;

my $stateDir = $ENV{"NIX_STATE_DIR"};
$stateDir = "@localstatedir@/nix" unless defined $stateDir;

my $storeDir = $ENV{"NIX_STORE_DIR"};
$storeDir = "@storedir@" unless defined $storeDir;


# Prevent access problems in shared-stored installations.
umask 0022;


# Process the URLs specified on the command line.
my %narFiles;
my %localPaths;
my %patches;

my $skipWrongStore = 0;

sub downloadFile {
    my $url = shift;
    $ENV{"PRINT_PATH"} = 1;
    $ENV{"QUIET"} = 1;
    my ($dummy, $path) = `$binDir/nix-prefetch-url '$url'`;
    die "cannot fetch `$url'" if $? != 0;
    die "nix-prefetch-url did not return a path" unless defined $path;
    chomp $path;
    return $path;
}

sub processURL {
    my $url = shift;

    $url =~ s/\/$//;

    my $manifest;

    # First see if a bzipped manifest is available.
    if (system("@curl@ --fail --silent --head '$url'.bz2 > /dev/null") == 0) {
        print "obtaining list of Nix archives at `$url.bz2'...\n";
        my $bzipped = downloadFile "$url.bz2";

        $manifest = "$tmpDir/MANIFEST";

        system("@bunzip2@ < $bzipped > $manifest") == 0
            or die "cannot decompress manifest";

        $manifest = (`$binDir/nix-store --add $manifest`
                     or die "cannot copy $manifest to the store");
        chomp $manifest;
    }

    # Otherwise, just get the uncompressed manifest.
    else {
        print "obtaining list of Nix archives at `$url'...\n";
        $manifest = downloadFile $url;
    }
    
    if (readManifest($manifest, \%narFiles, \%localPaths, \%patches) < 3) {
        die "`$url' is not manifest or it is too old (i.e., for Nix <= 0.7)\n";
    }

    if ($skipWrongStore) {
        foreach my $path (keys %narFiles) {
            if (substr($path, 0, length($storeDir) + 1) ne "$storeDir/") {
                print STDERR "warning: manifest `$url' assumes a Nix store at a different location than $storeDir, skipping...\n";
                exit 0;
            }
        }
    }

    my $baseName = "unnamed";
    if ($url =~ /\/([^\/]+)\/[^\/]+$/) { # get the forelast component
        $baseName = $1;
    }

    my $hash = `$binDir/nix-hash --flat '$manifest'`
        or die "cannot hash `$manifest'";
    chomp $hash;
    
    my $finalPath = "$stateDir/manifests/$baseName-$hash.nixmanifest";
    
    system("@coreutils@/ln", "-sfn", "$manifest", "$finalPath") == 0
        or die "cannot link `$finalPath to `$manifest'";
}

while (@ARGV) {
    my $url = shift @ARGV;
    if ($url eq "--skip-wrong-store") {
        $skipWrongStore = 1;
    } else {
        processURL $url;
    }
}


my $size = scalar (keys %narFiles) + scalar (keys %localPaths);
print "$size store paths in manifest\n";
