#! @perl@ -w

my $binDir = $ENV{"NIX_BIN_DIR"};
$binDir = "@bindir@" unless defined $binDir;


if (scalar @ARGV < 1) {
    print STDERR <<EOF
Usage: nix-copy-closure HOSTNAME [--sign] PATHS...
EOF
    ;
    exit 1;
}


# Get the target host.
my $sshHost = shift @ARGV;
my @sshOpts = split ' ', $ENV{"NIX_SSHOPTS"};

my $sign = 0;


# !!! Copied from nix-pack-closure, should put this in a module.
my %storePathsSeen;
my @storePaths = ();

while (@ARGV) {
    my $storePath = shift @ARGV;
    if ($storePath eq "--sign") {
        $sign = 1;
        next;
    }

    # $storePath might be a symlink to the store, so resolve it.
    $storePath = (`$binDir/nix-store --query --resolve '$storePath'`
        or die "cannot resolve `$storePath'");
    chomp $storePath;

    # Get the closure of this path.
    my $pid = open(READ,
        "$binDir/nix-store --query --requisites '$storePath'|") or die;
    
    while (<READ>) {
        chomp;
        die "bad: $_" unless /^\//;
        if (!defined $storePathsSeen{$_}) {
            push @storePaths, $_;
            $storePathsSeen{$_} = 1;
        }
    }

    close READ or die "nix-store failed: $?";
}


# Ask the remote host which paths are invalid.
open(READ, "-|", "ssh", @sshOpts, $sshHost, "nix-store", "--check-validity", "--print-invalid", @storePaths);
my @missing = ();
while (<READ>) {
    chomp;
    print STDERR "target needs $_\n";
    push @missing, $_;
}
close READ or die;


# Export the store paths and import them on the remote machine.
if (scalar @missing > 0) {
    my $extraOpts = "";
    $extraOpts .= "--sign" if $sign == 1;
    system("nix-store --export $extraOpts @missing | ssh @sshOpts $sshHost nix-store --import") == 0
        or die "copying store paths to remote machine failed: $?";
}
