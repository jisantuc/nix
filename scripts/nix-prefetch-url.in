#! @shell@ -e

url=$1
hash=$2

hashType=$NIX_HASH_ALGO
if test -z "$hashType"; then
    hashType=md5
fi    

if test -z "$url"; then
    echo "syntax: nix-prefetch-url URL" >&2
    exit 1
fi

# Determine the hash, unless it was given.
if test -z "$hash"; then

    # !!! race
    tmpPath1=@storedir@/nix-prefetch-url-$$

    # Test whether we have write permission in the store.  If not,
    # fetch to /tmp and don't copy to the store.  This is a hack to
    # make this script at least work somewhat in setuid installations.
    if ! touch $tmpPath1 2> /dev/null; then
        echo "(cannot write to the store, result won't be cached)" >&2
        dummyMode=1
        tmpPath1=/tmp/nix-prefetch-url-$$ # !!! security?
    fi

    # Perform the download.
    @curl@ --fail --location --max-redirs 20 "$url" > $tmpPath1

    # Compute the hash.
    hash=$(@bindir@/nix-hash --base32 --type "$hashType" --flat $tmpPath1)
    if ! test -n "$QUIET"; then echo "hash is $hash" >&2; fi

    # Rename it so that the fetchurl builder can find it.
    if test "$dummyMode" != 1; then
        tmpPath2=@storedir@/nix-prefetch-url-$hash
        test -e $tmpPath2 || mv $tmpPath1 $tmpPath2 # !!! race
    fi

fi

# Create a Nix expression that does a fetchurl.
storeExpr=$( \
    echo "(import @datadir@/nix/corepkgs/fetchurl) \
        {url = $url; outputHashAlgo = \"$hashType\"; outputHash = \"$hash\"; system = \"@system@\";}" \
    | @bindir@/nix-instantiate -)

# Realise it.
finalPath=$(@bindir@/nix-store -r $storeExpr)
    
if ! test -n "$QUIET"; then echo "path is $finalPath" >&2; fi

if test -n "$tmpPath1" -o -n "$tmpPath2"; then
    rm -rf $tmpPath1 $tmpPath2 || true
fi

echo $hash

if test -n "$PRINT_PATH"; then
    echo $finalPath
fi
