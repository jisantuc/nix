#! /usr/bin/perl -w

my @pushlist;

foreach my $id (@ARGV) {

    die unless $id =~ /^([0-9a-z]{32})$/;

    # Get all paths referenced by the normalisation of the given 
    # fstate expression.
    system "nix -ih $id";
    if ($?) { die "`nix -ih' failed"; }
    my @paths;
    open PATHS, "nix -qrh $id 2> /dev/null |" or die "nix -qrh";
    while (<PATHS>) {
        chomp;
        next unless /^\//;
        push @paths, $_;
    }
    close PATHS;

    # For each path, create a Fix expression that turns the path into
    # a Nix archive.
    foreach my $path (@paths) {

	next unless ($path =~ /\/([0-9a-z]{32})[^\/]*/);
	my $pathid = $1;

        # Construct a name for the Nix archive.  If the file is an
        # fstate successor, encode this into the name.
        my $name = $pathid;
        if ($path =~ /-s-([0-9a-z]{32}).nix$/) {
            $name = "$name-s-$1";
        }
        $name = $name . ".nar.bz2";

        # Construct a Fix expression that creates a Nix archive.
        my $fixexpr = 
          "App(IncludeFix(\"nar/nar.fix\"), " .
          "[ (\"path\", Slice([\"$pathid\"], [(\"$path\", \"$pathid\", [])]))" .
          ", (\"name\", \"$name\")" .
          "])";
	
        my $fixfile = "/tmp/nix-push-tmp.fix";
        open FIX, ">$fixfile";
        print FIX $fixexpr;
        close FIX;

        # Instantiate a Nix expression from the Fix expression.
        my $nid = `fix $fixfile`;
        $? and die "instantiating Nix archive expression";
        chomp $nid;
        die unless $nid =~ /^([0-9a-z]{32})$/;

        # Realise the Nix expression.
	system "nix -ih $nid";
	if ($?) { die "`nix -ih' failed"; }
        my $npath = `nix -qph $nid 2> /dev/null`;
        $? and die "creating Nix archive";
        chomp $npath;

        push @pushlist, $npath;

        print "$path -> $npath\n";
    }
}

# Push the prebuilts to the server. !!! FIXME
if (scalar @pushlist > 0) {
    system "rsync -av -e ssh @pushlist eelco\@losser.st-lab.cs.uu.nl:/home/eelco/public_html/nix-dist/";
}
